# 第6章——详解持久化技术

## 6.1 持久化技术简介

数据持久化就是指将内存中的瞬时数据保存到存储设备中，保证即时在手机或电脑关机的情况下，这些数据也不会丢失。

持久化技术主要通过下面三种方式：

*    文件存储
*    SharedPreference存储
*    数据库存储



## 6.2 文件存储

### 6.2.1 将数据存储到文件中

Context类中提供了一个**openFileOutput()**方法，可以用于将数据存储到指定的文件夹中。

这个方法接收两个参数，第一个参数是`文件名`，第二个参数是文件的操作模式：

*    `MODE_PRIVATE`:指定已存在文件的文件名的时候，所写入的内容会覆盖原文件的内容，是默认的模式。
*    `MODE_APPEND`指定已存在文件的文件名的时候，所写入的内容追加在文件最后。

这个方法的具体使用方法：

1.   通过`BufferdWriter.write()`方法写入数据
2.   `BufferdWriter`构建方法中接收一个`OutputStreamWriter`对象
3.   `OutputStreamWriter`构建方法中接受一个`FifleOutputStream`对象
4.   可以通过`openFileOutput()`方法获得`FifleOutputStream`对象



即 **文件输出流 - > 数据输出流 -> 缓冲区输出流**

```java
    public void save(String inputText){
        FileOutputStream out = null;
        BufferedWriter writer = null;

        try {
            out = openFileOutput("data", Context.MODE_PRIVATE);
            writer = new BufferedWriter(new OutputStreamWriter(out));
            writer.write(inputText);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try{
                if (writer != null){
                    writer.close();
                }
            }catch (IOException e){
                e.printStackTrace();
            }

        }
    }
```



### 6.2.2 从文件中读取数据

主要步骤是：

1.   通过`BufferedReader.readLine()`方法将文件内容一行行读取，内容存放在StringBuilder对象中，最后返回`return StringBuilder.toString()`;
2.   `BufferedReader`的构建方法中接受一个`InputStreamReader`对象
3.   `InputStreamReader`构建方法中接收一个`FileInputStream`对象
4.   通过`openFileInput("data")`可以获取到`FileInputStream`的实例。



即**文件输入流 -> 数据输入流 -> 缓冲区输入流**



```java
    public String load(){
        FileInputStream in = null;
        BufferedReader reader = null;
        StringBuilder content = new StringBuilder();

        try {
            in = openFileInput("data");
            reader = new BufferedReader(new InputStreamReader(in));
            String line = "";
            while ((line = reader.readLine()) != null){
                content.append(line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (reader != null){
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return content.toString();

    }
```



## 6.3 SharedPreferences 存储

不同于文件的存储方式，**SharedPreferences是使用键值对的方式来存储数据的。**

*    当保存一条数据的时候，需要给这条数据提供一个对应的键
*    读取这条数据的时候就可以通过这个键把相应的值取出来



### 6.3.1 将数据存储到 SharedPreferences中

首先要获取到`SharedPrefenrences`对象，有三种方法：

1.   Context类中的getSharedPreferences()方法：

此方法接收两个参数，第一个参数用于指定SharedPreferences文件的名称，如果不存在则会创建一个，SharedPreferences 文件**存放在`/data/data/<package name>/shared_prefs/`目录下**。

第二个参数用于指定操作模式，只有MODE_PRIVATE一种模式可选。

2.   Activity类中的getPreferences()方法：

这个方法与上面的很类似，只接收一个操作模式参数。**使用这个方法会自动将当前活动的类名作为SharedPreferences的文件名。**

3.   PreferenceManager类中的getDefaultSharedPreferences()方法：

它只接收一个Context参数，并自动使用当前应用程序的包名最为前缀来命名SharedPreferences文件。



**向ShredPreferences文件存储数据：**

1.   调用`SharedPreferenced.edit()`方法获取 SharedPreferences.Editor对象
2.   向`SharedPreferences.Editor`对象中添加数据：添加字符串使用 putString()，其他同理
3.   调用Editor的`apply()`方法将添加的数据提交，从而完成数据存储操作

```java
                SharedPreferences.Editor editor = getSharedPreferences("data", MODE_PRIVATE).edit();
                editor.putString("name","Tome");
                editor.putInt("age", 28);
                editor.putBoolean("married", false);
                editor.apply();
```



### 6.3.2 从SharedPreferences中读取数据

`SharedPreferences`对象提供了一系列的get方法，比如`getString()` 、`getBoolean()`等等。

这些方法都接收两个参数：

*    一个参数是键
*    第二个参数是默认值，表示当传入的键找不到对应的值时返回的值

```java
                SharedPreferences pref = getSharedPreferences("data",MODE_PRIVATE);
                String name = pref.getString("name", "");
                int age = pref.getInt("age", 0);
                boolean married = pref.getBoolean("married", false);
                Log.d("MainActivity2","name is "+ name);
                Log.d("MainActivity2","age is " + age);
                Log.d("MainActivity2", "married is " + married);
```



### 6.3.3 实现记住密码功能

其实很简单，分为两个部分：



**登录的时候，账号密码正确将数据存储：**

```java
                    editor = pref.edit();
                    if (rememberPass.isChecked()){
                        editor.putBoolean("remember_password", true);
                        editor.putString("account",account);
                        editor.putString("password", password);
                    }else {
                        editor.clear();
                    }
                    editor.apply();
```



**进入该活动界面的时候，根据是否记住密码读取数据：**

```java
        if (isRemember){
            String account = pref.getString("account", "");
            String password = pref.getString("password","");
            accountEdit.setText(account);
            passwordEdit.setText(password);
            rememberPass.setChecked(true);
        }
```



## 6.4 SQLite 数据库存储

主要是 添加、查询、更新、删除这四种对数据的操作。

### 6.4.1 创建数据库

借助这个 SQLiteOpenHelper来对数据库进行创建和升级：

*    这是个抽象类，必须创建一个自己的帮助类继承它
*    有两个抽象方法，onCreat() onUpgrade()我们必须重写这两个方法。

我们**可以通过SQLiteOpenHelper两个重要的方法来创建或者打开数据库**：

*    getReadableDatabase():当数据库不可写入的时候，返回的对象将以只读的方式去打开数据库。
*    getWritableDatabase():当数据库不可写入的时候，将会出现异常。



创建的数据库文件将会存放在`data/data/<package name>/databses`目录下



注意：**只有第一次通过这个对象调用getReadableDatabase或者getWritableDatabase函数时才会调用onCreate函数，**而如果调用过一次这个对象的getReadableDatabase或者getWritableDatabase函数后系统将不会再调用onCreate函数。



**在onCreate()函数中创建数据库：**

```java
    @Override
    public void onCreate(SQLiteDatabase sqLiteDatabase) {
        sqLiteDatabase.execSQL(CREATE_BOOK);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }
```





### 6.4.2 升级数据库

使用MyDatabaseHelpet的`onUpgrade()`方法对数据库升级：



我们想再建一张Category表用于记录图书的分类：

建表语句：

```mysql
    public static final String CREATE_CATEGORY = "create table category ("
            + "id integer primary key autoincrement,"
            + "category_name text,"
            + "category_code integer)";
```



onCreate():

```java
    @Override
    public void onCreate(SQLiteDatabase sqLiteDatabase) {
        sqLiteDatabase.execSQL(CREATE_BOOK);
        sqLiteDatabase.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext, "Create succeeded", Toast.LENGTH_SHORT).show();
    }
```



onUpgrade():

```JAVA
    @Override
    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {
        sqLiteDatabase.execSQL("drop table if exists Book");
        sqLiteDatabase.execSQL("drop table if exists Category");
        onCreate(sqLiteDatabase);
    }
```



这里注意一下onUpgrade()函数中，先删除了旧的表，然后再执行onCreate()方法。要知道，只会在创建数据库的时候才会调用onCreate()方法，后面如果需要修改数据库，只能通过onUpgrade()方法！



最后就是在创建数据库的时候，修改一下数据库的版本号

```java
dbHelper = new MyDatabaseHelper(this,"BookStore.db", null, 2);
```



### 6.4.3 添加数据

SQLiteDatabse 提供一个`insert()`方法，这个方法接收3个参数：

*    第一个参数是表名，指定向哪个表中添加数据
*    第二个参数，通常传入null即可。
*    第三个参数是一个ContentValues对象

ContentValuse显然是用来存储数据，提供一系列的put()方法重载。

这些方法接收两个参数：

*    第一个参数是列名
*    第二个参数是待添加的数值

```java
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                ContentValues values = new ContentValues();

                values.put("name", "The Da Vinci Code");
                values.put("author", "Dan Brown");
                values.put("pages", 454);
                values.put("price", 16.96);
                db.insert("Book", null, values);
                values.clear();

                values.put("name","The Lost Symbol");
                values.put("author", "Dan Brown");
                values.put("pages", 10);
                values.put("price", 19.95);
                db.insert("Book", null, values);
```



### 6.4.4 更新数据



如果想要修改表中已有的数据，SQLiteDatabase中也提供了已非常好用的update()方法，用于对数据进行更新。这个方法接收4个参数：

*    第一个参数是表名，指定更新哪张表里的数据
*    第二个参数是ContentValuse对象，在这里存储要更新的数据。
*    第三个第四个参数用于约束更新某一行或者某几行的数据，不指定即默认更新所有行。

```java
                SQLiteDatabase db = dbHelper.getWritableDatabase();
                ContentValues values = new ContentValues();
                values.put("price",10.99);
                db.update("Book",values, "name = ?", new String[]{"The Da Vinci Code"});
```



### 6.4.5 删除数据

通过SQLiteDatabase的delete()fafang方法，这个方法同样接收四个参数，参数规则和上面一样：

```java
SQLiteDatabase db = dbHelper.getWritableDatabase();
db.delete("Book","pages > ?", new String[]{"400"});
```



### 6.4.6 查询数据

SQLiteDatabse提供一个query()方法进行查询，这个方法有很多重载的方法，最短的一个方法也需要传入7个参数：

*    第一个参数是表名
*    第二个参数是指定查询哪几列，如果不指定则默认查询所有列
*    第三第四个参数用于约束查询某一行或某几行的数据，不指定默认查询所有行数据
*    第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作
*    第六个参数用于对group by之后的数据进行进一步的过滤，不指定则表示不进行过滤
*    第七个参数用于指定查询结果的排序方式，不指定则使用默认的排序方式





## 6.5 使用LitePal操作数据库 